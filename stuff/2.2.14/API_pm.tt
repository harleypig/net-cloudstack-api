package Net::CloudStack::API;

# ABSTRACT: Basic request and response handling for calls to a CloudStack service.

use strict;
use warnings;
use namespace::autoclean;

use Carp;
use Net::CloudStack;
use Params::Validate ':all';
use Scalar::Util 'blessed';
use Sub::Exporter;

my @exports;

{ # Begin general hiding

##############################################################################
# Base structure

my $command = [% cmd_dump %];

##############################################################################
# Setup exports

my ( $exports, $groups, @all );

for my $cmd ( keys %$command ) {

  $exports->{ $cmd } = \&_generate_method;
  push @{ $groups->{ $command->{ $cmd }{ section } } }, $cmd;
  push @all, $cmd;

}

$groups->{ all } = \@all;

my $config = {

  exports => $exports,
  groups  => $groups,

};

Sub::Exporter::setup_exporter( $config );

##############################################################################
# Setup OO interface

# handle either a list of elements or a hashref

sub new { bless {}, ref $_[0] || $_[0] }

our $AUTOLOAD;

sub AUTOLOAD {

  my $self = shift;

  ( my $method = $AUTOLOAD ) =~ s/^.*:://;

  croak "unknown method $method"
    unless exists $command->{ $method };

  no strict 'refs';
  *$AUTOLOAD = $self->_generate_method( $method );

  goto &$AUTOLOAD;

}

sub DESTROY {}

##############################################################################
# Utility methods

sub _generate_method {

  shift if blessed $_[0]; # Don't need to know which class we are if we're an object.

  my $cmd = shift;

  croak "Unknown method: $cmd"
    unless exists $command->{ $cmd };

  # FIXME: more robust handling of at least the obvious data types.
  my %validate;

  # Only build this part of the hash once ...
  $validate{ spec }{ $_ } = { type => SCALAR }
    for keys %{ $command->{ $cmd }{ request }{ required } };

  $validate{ spec }{ $_ } = { type => SCALAR, optional => 1 }
    for keys %{ $command->{ $cmd }{ request }{ optional } };

  return sub {

    my $self = shift
      if blessed $_[0];

    $validate{ params } = \@_;
    my %arg = validate_with( %validate );

    my @proc = $cmd;

    ( push @proc, join '&', map { "$_=$arg{$_}" } keys %arg )
      if keys %arg;


    if ( blessed $self ) {

      return $self->api->proc( @proc )->response;

    } else {

      return api()->proc( @proc )->response;

    }
  };
}

{ # Hide api stuff

  # Functional interface just returns an instance of an Net::CloudStack object.
  # OO interface creates an instance if one does not exist in the current instance of this package.

  my $api;

  sub api {

    my ( $self, $args, $work );

    if ( @_ && blessed $_[0] ) { # OO interface

      ( $self, $args ) = @_;

      return $self->{ api } = Net::CloudStack->new( $args )
        if ! exists $self->{ api };

      croak "unexpected api condition (oo)"
        if ! blessed $self->{ api } || blessed $self->{ api } ne 'Net::CloudStack';

      $work = $self->{ api };

    } else { # Functional interface

      $args = shift;

      return $api = Net::CloudStack->new( $args )
        if ! blessed $api;

      croak "unexpected api condition (functional)"
        if blessed $api ne 'Net::CloudStack';

      $work = $api;

    }

    croak "args must be a hashref"
      unless ref $args eq 'HASH';

    $work->$_( $args->{ $_ } )
      for keys %$args;

  }
} # End hiding api stuff

} # End general hiding

1;
